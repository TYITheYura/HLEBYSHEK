// Обработчик, который загружается после того, как загрузится html. Стрелочная функция (имхо, толком объяснить что это уже не смогу)
document.addEventListener("DOMContentLoaded", () => {
    // переменная (константа, нельзя переназначить когда скрипт активен), где указываются элементы из документа (html), которые будут анимироваться.
    // Выдаёт псевдомассив найденных (указанных) элеметов АКА NodeList. Считай, теперь можно перебирать его внутренности через forEach (каждый элемент), применяя к ним разные методы
    const elementsToAnimate = document.querySelectorAll(
        ".main__second-window-text-block, .main__second-window-titles"
    );
    // Опа! А вот ещё одна константа, думал в математике только такое есть? А хуй там!
    // В общем, IntersectionObserver - объект (WebAPI тула кстати, интересный факт), который чекает, есть ли элемент/появился ли он в зоне видимости (вьюпорта)
    // В кратце - отслеживает появление элемента на экране
    const observer = new IntersectionObserver(
        // Функция обработчик (стрелочная btw). Тут entries - массив объектов IntersectionObserverEntry. В данных масивах есть инфа о наблюдаемых элементах.
        (entries) => {
            // Вотут проходимся по каждому элементу из массива entries. В entry содержаться данные о состоянии объекта
            entries.forEach((entry) => {
                // Функция проверки из IntersectionObserverEntry. entry.isIntersecting передаёт либо true, либо false, в зависимости есть ли элемент в зоне видимости
                if (entry.isIntersecting) {
                    // Этот кусок кода выполняется, когда entry.isIntersecting === true, т.е. элемент уже видно на n% (threshold внизу).
                    // Даём свободу анимациям, которые написаны в css! Добавляя значение класса .animate (стили для которых есть в css заранее) в html для элементов, которые указаны в elementsToAnimate, выполняется анимация. Фактически, таким образом, мы редачим html с помощью js.
                    entry.target.classList.add("animate");
                    // Тут убираем элементы из списка наблюдений, ибо если этого не делать, анимация может повторяться.
                    observer.unobserve(entry.target);
                }
            });
        },
        // А вотут мы и задаём процент видимости элемента. Пороговое значение, при котором анимка воспроизводится
        // Цэ второй параметр IntersectionObserver
        { threshold: 0.3 }
    );

    // Как и говорилось, через foreach к elementsToAnimate можно применить разные методы.
    // Тут как раз это и делаем (считай, "запускаем" скрипт, который написан выше)
    // Применяем метод через foreach для каждого элемента (el - элемент, который foreach берёт из массива. Применяет... Потом ещё один берёт, и так пока массив не кончится.)
    elementsToAnimate.forEach((el) => observer.observe(el));
});

// ай какой малаца ебать тут серых букаф